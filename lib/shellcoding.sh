# Copyright 2015-2016 Gu Zhengxiong <rectigu@gmail.com>
#
# This file is part of Unish.
#
# Unish is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License
# as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Unish is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Unish.  If not, see <http://www.gnu.org/licenses/>.


# TODO:
# This code is deprecated, and is first written in mkhex.sh,
# which resides at https://github.com/NoviceLive/shellcoding.
# The same functionality will be better implemented in IntelliCoder,
# which will be available at
# https://github.com/NoviceLive/intellicoder when it's ready.


mksc.sh() {
    if [[ $# -lt 1 ]]; then
        return 1
    fi
    case "$2" in
        -e|--escape)
            flag=0;;
        -r|--raw)
            flag=1;;
        -c|--c)
            flag=2;;
        -l|--linux)
            flag=3;;
        -w|--windows)
            flag=4;;
        *)
            flag=0;;
    esac

    if [[ $flag -ge 2 ]]; then
        cat <<EOF
/*
 * This file was automatically generated by mkhex.sh,
 * which, together with the complete
 * and heavily commented assembly source code
 * for this shellcode, is available at
 * https://github.com/NoviceLive/shellcoding.
 *
 * For those curious heads
 * striving to figure out what's under the hood.
 */


# include <stdlib.h>
# include <stdio.h>
EOF
        if [[ $flag -eq 3 ]]; then
            cat <<EOF
# include <stdint.h>

# include <sys/mman.h>
EOF
        fi

        if [[ $flag -eq 4 ]]; then
            cat <<EOF

# include <windows.h>
EOF
        fi
        cat <<EOF

# define COUNTOF(a) (sizeof(a) / sizeof(a[0]))


int
main(void)
{
EOF
        printf '  char shellcode[] = "'
    fi

    trhex "$1" $flag

    if [[ $flag -ge 2 ]]; then
        printf '";\n\n'
        if [[ $flag -eq 3 ]]; then
            cat <<EOF
  int failure = mprotect((void *)((uintptr_t)shellcode & ~4095),
    4096, PROT_READ | PROT_WRITE | PROT_EXEC);

  if (failure) {
    printf ("mprotect\n");
    return EXIT_FAILURE;
  }

EOF
        fi
        if [[ $flag -eq 4 ]]; then
            cat <<EOF
  DWORD why_must_this_variable;
  BOOL success = VirtualProtect(shellcode, COUNTOF(shellcode),
    PAGE_EXECUTE_READWRITE, &why_must_this_variable);

  if (!success) {
    printf ("VirtualProtect\n");
    return EXIT_FAILURE;
  }

EOF
        fi
        cat <<EOF
  printf("strlen(shellcode)=%d\n", COUNTOF(shellcode));

  ((void (*)(void))shellcode)();

  return EXIT_SUCCESS;
}
EOF
    fi
}


objhex() {
    if [[ $# -lt 1 ]]; then
        return 1
    fi
    local regex
    regex='(?<=\t)([0-9a-f]{2}\s)+'
    local hex
    hex="$(objdump -d "$1" | grep -oP "${regex}")"
    printf '%s' "${hex}" | sed -r 's/(90)*$//g' | tr -d ' \n'
}


trhex() {
    if [[ $# -lt 1 ]]; then
        return 1
    fi
    local i=0
    local c=0
    local fmt
    if [[ $2 -eq 1 ]]; then
        fmt='%s'
    else
        fmt='\\x%s'
    fi
    while [[ $i -lt ${#1} ]]; do
        if [[ $2 -ge 2 && $c -eq 10 ]]; then
            c=0
            printf '"\n    "'
        fi

        printf "${fmt}" "${1:$i:2}"
        i=$((i+2))
        c=$((c+1))
    done
}
